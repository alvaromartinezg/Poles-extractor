<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>BITEL MT pole extractor v3</title>

    <!-- Anti-cache del HTML -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">

    <!-- Peque√±as optimizaciones de red -->
    <link rel="preconnect" href="https://unpkg.com">
    <link rel="dns-prefetch" href="https://unpkg.com">

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script defer src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script defer src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    <script defer src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
    <script defer src="https://unpkg.com/@tmcw/togeojson@5.8.1/dist/togeojson.umd.js"></script>
    <script defer src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

    <style>
        :root {
            --accent: #10b981;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, sans-serif;
            background: #f3f4f6;
            color: #111827;
            margin: 0;
        }

        header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 20px;
            justify-content: center;
        }

        header img {
            height: 48px;
        }

        h1 {
            font-size: 22px;
            margin: 0;
            font-weight: 700;
        }

        .bar {
            display: flex;
            gap: 12px;
            justify-content: center;
            padding: 16px;
            flex-wrap: wrap;
        }

        .btn {
            background: #2d2d2d;
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
        }

        .btn.secondary {
            background: #6b7280;
        }

        .btn.accent {
            background: var(--accent);
        }

        .btn:disabled {
            opacity: .6;
            cursor: not-allowed;
        }

        .card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 6px 18px rgba(0, 0, 0, .08);
            width: min(1100px, 92vw);
            margin: 0 auto 18px;
            padding: 16px;
        }

        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        input[type="number"],
        input[type="file"] {
            padding: 10px 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
        }

        #map {
            height: 520px;
            border-radius: 12px;
        }

        textarea {
            width: 100%;
            min-height: 180px;
            border: 1px solid #d1d5db;
            border-radius: 10px;
            padding: 12px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }

        .pill {
            background: #e5e7eb;
            padding: 6px 10px;
            border-radius: 999px;
            font-size: 12px;
        }

        .muted {
            color: #6b7280;
        }

        .status {
            font-size: 12px;
            color: #374151;
            display: grid;
            grid-auto-flow: column;
            gap: 18px;
            width: max-content;
        }

        .ok {
            color: #059669;
        }

        .bad {
            color: #dc2626;
        }

        .kpi {
            font-size: 13px;
            margin: 6px 0 10px;
        }

        .kpi b {
            color: #111827;
        }
    </style>
</head>

<body>
    <header>
        <h1>BITEL MT pole extractor</h1>
    </header>

    <div class="bar">
        <input id="fileLine" type="file" accept=".kmz,.kml" hidden />
        <button class="btn accent" id="btnPickLine">Seleccionar L√≠nea KMZ/KML</button>
        <span class="pill">Base: <b id="baseName">postes.csv.zip</b></span>
        <label class="pill">Radio (m): <input id="radius" type="number" value="20" min="1"></label>
        <button class="btn" id="btnExtract">Extraer</button>
        <button class="btn" id="btnCopy">Copiar</button>
        <button class="btn" id="btnDownloadTXT">Descargar TXT</button>
        <button class="btn" id="btnDownloadKMZ">Descargar KMZ</button>
        <button class="btn secondary" id="btnShowMap">Ver en mapa</button>
    </div>

    <div class="card">
        <div class="row muted" style="margin-bottom:8px;">
            <span>La app cargar√° <b>postes.csv.zip</b> cuando lo necesite. Tambi√©n puedes cargar CSV(s)
                manualmente:</span>
            <input id="filePosts" type="file" accept=".csv" multiple>
        </div>
        <div class="status">
            <div id="statusPosts">Postes cargados: <b>0</b></div>
            <div id="statusLine">L√≠nea: <b class="bad">no cargada</b></div>
            <div id="statusResult">Filtrados: <b>0</b></div>
        </div>
        <div id="map" style="display:none; margin-top:10px;"></div>
    </div>

    <div class="card">
        <div id="compare" class="kpi muted">Comparaci√≥n de longitudes: <b>‚Äî</b></div>
        <textarea id="output" placeholder="INICIO;lat;lon&#10;Nombre;lat;lon&#10;...&#10;FIN;lat;lon"></textarea>
    </div>

    <!-- === NUEVA TARJETA: Dise√±o de postes de Madera (ADICI√ìN) === -->
    <div id="designCard" class="card" style="display:none;">
        <h3 style="margin:6px 0 12px;">Dise√±ar postes de Madera</h3>
        <div class="row">
            <label class="pill">Origen:
                <select id="designStart"></select>
            </label>
            <label class="pill">Fin:
                <select id="designEnd"></select>
            </label>
            <label class="pill">Distancia (m):
                <input id="designSpacing" type="number" value="60" min="5" step="1">
            </label>
            <button class="btn" id="btnPreviewDesign">Previsualizar</button>
            <button class="btn accent" id="btnInsertDesign" disabled>Insertar al resultado</button>
            <button class="btn secondary" id="btnClearDesign">Limpiar dise√±o actual</button>
        </div>
        <div class="kpi muted">Generados: <b id="designCount">0</b></div>
        <div class="muted" style="font-size:12px;">
            1) Elige origen y fin (de los postes extra√≠dos). 2) Define distancia. 3) Previsualiza (en rojo). 4) Inserta
            al resultado (TXT/KMZ se actualizar√°n). Puedes repetir cuantas veces quieras.
        </div>
    </div>


    <script>
        (function () {
            const ZIP_NAME = "postes.csv.zip";
            let postes = [];          // [{name, lat, lon}]
            let filtered = [];        // [{name, lat, lon, location, distance}]
            let line = null;          // Feature<LineString>
            let map, layerLine, layerPostesFiltered;
            let postsLoaded = false;

            // ---------- Estado UI ----------
            const elBase = document.getElementById("baseName");
            const stPosts = document.getElementById("statusPosts");
            const stLine = document.getElementById("statusLine");
            const stRes = document.getElementById("statusResult");
            const elCompare = document.getElementById("compare");
            function setPostsCount(n) { stPosts.innerHTML = "Postes cargados: <b>" + n + "</b>"; }
            function setLineLoaded(ok) {
                stLine.innerHTML = "L√≠nea: <b class='" + (ok ? "ok" : "bad") + "'>" + (ok ? "cargada" : "no cargada") + "</b>";
            }
            function setResultCount(n) { stRes.innerHTML = "Filtrados: <b>" + n + "</b>"; }
            function setCompareText(t) { elCompare.innerHTML = "Comparaci√≥n de longitudes: <b>" + t + "</b>"; }

            // ---------- Utilidades ----------
            async function fetchBlob(url) {
                const r = await fetch(url + "?v=" + Date.now(), { cache: "no-store" });
                if (!r.ok) throw new Error("No se pudo cargar " + url);
                return await r.blob();
            }

            // PapaParse en worker (no bloquea la UI)
            function parseCSVWithPapaAsync(text) {
                return new Promise((resolve) => {
                    const out = [];
                    Papa.parse(text, {
                        header: true,
                        skipEmptyLines: true,
                        worker: true,
                        step: (row) => {
                            const r = row.data;

                            // Lee lat/lon con los alias m√°s comunes
                            const lat = parseFloat(r.Latitud ?? r.lat ?? r.LAT ?? r.latitude ?? r.Latitude);
                            const lon = parseFloat(r.Longitud ?? r.lon ?? r.LON ?? r.longitude ?? r.Longitude);

                            // ‚úÖ Usar directamente la columna "name" (primera del CSV)
                            let name = (r.name ?? r.Nombre ?? r.NOMBRE ?? r.NAME ?? "").toString().trim();

                            if (!isNaN(lat) && !isNaN(lon)) {
                                if (!name) name = "Poste"; // Fallback simple
                                out.push({ name, lat, lon });
                            }
                        },
                        complete: () => resolve(out)
                    });
                });
            }

            async function loadCSVFromZip(zipName = ZIP_NAME) {
                const blob = await fetchBlob(zipName);
                const zip = await JSZip.loadAsync(blob);
                const entry = Object.keys(zip.files).find(n => n.toLowerCase().endsWith(".csv"));
                if (!entry) throw new Error("El ZIP no contiene un CSV");
                const csvText = await zip.files[entry].async("text");
                return await parseCSVWithPapaAsync(csvText);
            }

            // ‚Üê ESTA ES LA FUNCI√ìN QUE YA TIENES
            async function ensurePostsLoaded() {
                if (postsLoaded) return;
                try {
                    postes = await loadCSVFromZip(ZIP_NAME);
                    postsLoaded = true;
                    setPostsCount(postes.length);
                    elBase.textContent = `${ZIP_NAME} (${postes.length} pts)`;
                } catch (e) {
                    console.warn("No se pudo cargar postes.csv.zip autom√°ticamente:", e);
                    elBase.textContent = `${ZIP_NAME} (no cargado)`;
                    alert("No se pudo cargar postes.csv.zip. Puedes cargar CSV(s) manualmente.");
                }
            }

            async function readKMZtoKMLText(file) {
                const zip = await JSZip.loadAsync(file);
                const kmlEntry = Object.keys(zip.files).find(n => n.toLowerCase().endsWith(".kml"));
                if (!kmlEntry) throw new Error("El KMZ no contiene un KML");
                return await zip.files[kmlEntry].async("text");
            }

            function parseKmlTextToGeoJSON(kmlText) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(kmlText, "text/xml");
                return toGeoJSON.kml(doc);
            }

            function lineStringFromGeojson(gj) {
                for (const f of gj.features || []) {
                    if (f.geometry && f.geometry.type === "LineString") return f;
                }
                return null;
            }

            // --- Prefiltro por BBOX + margen ---
            function metersToLatDeg(m) { return m / 111320; }
            function metersToLonDegAtLat(m, latDeg) {
                const k = 111320 * Math.cos(latDeg * Math.PI / 180);
                return m / (k === 0 ? 1 : k);
            }
            function bboxWithMargin(lineFeature, marginM) {
                const [minLon, minLat, maxLon, maxLat] = turf.bbox(lineFeature);
                const midLat = (minLat + maxLat) / 2;
                const dLat = metersToLatDeg(marginM);
                const dLon = metersToLonDegAtLat(marginM, midLat);
                return [minLon - dLon, minLat - dLat, maxLon + dLon, maxLat + dLat];
            }
            function preselectByBbox(points, bbox) {
                const [minLon, minLat, maxLon, maxLat] = bbox;
                return points.filter(p => (
                    p.lat >= minLat && p.lat <= maxLat &&
                    p.lon >= minLon && p.lon <= maxLon
                ));
            }

            // --- C√°lculo final (solo sobre candidatos del bbox) ---
            function computeAlongLine(radiusM) {
                if (!line || !postes.length) return [];
                const bbox = bboxWithMargin(line, radiusM + 30); // holgura
                const candidates = preselectByBbox(postes, bbox);

                const startCoord = line.geometry.coordinates[0];
                const startPt = turf.point(startCoord);
                const out = [];

                for (const p of candidates) {
                    const pt = turf.point([p.lon, p.lat]);
                    const distM = turf.pointToLineDistance(pt, line, { units: "meters" });
                    if (distM > radiusM) continue;

                    const proj = turf.nearestPointOnLine(line, pt, { units: "meters" });
                    const slice = turf.lineSlice(startPt, proj, line);
                    const locM = turf.length(slice, { units: "kilometers" }) * 1000;

                    out.push({ ...p, distance: distM, location: locM });
                }
                out.sort((a, b) => a.location - b.location);
                return out;
            }

            function resultToTextOrdered(rows) {
                if (!line) return "";
                const start = line.geometry.coordinates[0];
                const end = line.geometry.coordinates[line.geometry.coordinates.length - 1];
                const lines = [];
                lines.push(`INICIO;${start[1].toFixed(6)};${start[0].toFixed(6)}`);
                rows.forEach(r => lines.push(`${r.name};${r.lat.toFixed(6)};${r.lon.toFixed(6)}`));
                lines.push(`FIN;${end[1].toFixed(6)};${end[0].toFixed(6)}`);
                return lines.join("\n");
            }

            function escapeXml(s) { return s.replace(/[<>&'"]/g, c => ({ "<": "&lt;", ">": "&gt;", "&": "&amp;", "'": "&apos;", '"': "&quot;" }[c])); }

            function buildKML(rows) {
                const header = `<?xml version="1.0" encoding="UTF-8"?>\n<kml xmlns="http://www.opengis.net/kml/2.2"><Document>`;
                const footer = `</Document></kml>`;
                const style = `<Style id="line"><LineStyle><color>ff00aaff</color><width>3</width></LineStyle></Style>
                   <Style id="pt"><IconStyle><color>ff10b981</color><scale>1.1</scale>
                   <Icon><href>http://maps.google.com/mapfiles/kml/paddle/grn-blank.png</href></Icon></IconStyle></Style>`;
                let linePlm = "";
                if (line) {
                    const coords = line.geometry.coordinates.map(([lon, lat]) => `${lon},${lat},0`).join(" ");
                    linePlm = `<Placemark><name>L√≠nea cargada</name><styleUrl>#line</styleUrl><LineString><coordinates>${coords}</coordinates></LineString></Placemark>`;
                }
                const ptsPlm = rows.map(r => `<Placemark><name>${escapeXml(r.name)}</name><styleUrl>#pt</styleUrl><Point><coordinates>${r.lon},${r.lat},0</coordinates></Point></Placemark>`).join("");
                return header + style + linePlm + ptsPlm + footer;
            }

            function updateLengthComparison(rows) {
                if (!line) { setCompareText("‚Äî"); return; }
                const originalLenM = turf.length(line, { units: "kilometers" }) * 1000;
                const start = line.geometry.coordinates[0];
                const end = line.geometry.coordinates[line.geometry.coordinates.length - 1];
                const genCoords = [start, ...rows.map(r => [r.lon, r.lat]), end];
                const generatedLenM = genCoords.length >= 2
                    ? turf.length(turf.lineString(genCoords), { units: "kilometers" }) * 1000
                    : 0;
                const dif = generatedLenM - originalLenM;
                const f = n => n.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ".");
                setCompareText(`Original: ${f(originalLenM)} m | Generada (uniendo postes): ${f(generatedLenM)} m | Œî: ${f(dif)} m`);
            }

            // ---------- Eventos UI ----------
            document.getElementById("btnPickLine").onclick = () => document.getElementById("fileLine").click();

            document.getElementById("fileLine").addEventListener("change", async (ev) => {
                const file = ev.target.files[0]; if (!file) return;
                let kmlText;
                if (file.name.toLowerCase().endsWith(".kmz")) kmlText = await readKMZtoKMLText(file);
                else kmlText = await file.text();
                const gj = parseKmlTextToGeoJSON(kmlText);
                line = lineStringFromGeojson(gj);
                setLineLoaded(!!line);
                if (!line) { alert("No se encontr√≥ una LineString en el archivo."); return; }
                setCompareText("‚Äî");
                // PRECARGA la base justo despu√©s de cargar la l√≠nea
                await ensurePostsLoaded();
            });

            // Carga manual de CSV(s) (fallback)
            document.getElementById("filePosts").addEventListener("change", async (ev) => {
                postes = [];
                for (const file of ev.target.files) {
                    const txt = await file.text();
                    const arr = await parseCSVWithPapaAsync(txt);
                    postes.push(...arr);
                }
                postsLoaded = true;
                setPostsCount(postes.length);
                elBase.textContent = `Cargados manualmente (${postes.length} pts)`;
                alert("Base de postes cargada: " + postes.length + " puntos.");
            });

            document.getElementById("btnExtract").onclick = async () => {
                if (!line) { alert("Carga primero la L√çNEA (KMZ/KML)."); return; }
                if (!postsLoaded) { await ensurePostsLoaded(); if (!postsLoaded) return; }

                const radius = Number(document.getElementById("radius").value) || 20;
                filtered = computeAlongLine(radius);

                document.getElementById("output").value = resultToTextOrdered(filtered);
                setResultCount(filtered.length);
                updateLengthComparison(filtered);
            };

            document.getElementById("btnCopy").onclick = async () => {
                const txt = document.getElementById("output").value || "";
                if (!txt) { alert("No hay contenido para copiar"); return; }
                await navigator.clipboard.writeText(txt);
                alert("Resultado copiado al portapapeles.");
            };

            document.getElementById("btnDownloadTXT").onclick = () => {
                const txt = document.getElementById("output").value || "";
                const blob = new Blob([txt], { type: "text/plain;charset=utf-8" });
                const a = document.createElement("a");
                a.href = URL.createObjectURL(blob);
                a.download = "postes_filtrados.txt";
                a.click();
                URL.revokeObjectURL(a.href);
            };

            document.getElementById("btnDownloadKMZ").onclick = async () => {
                if (!filtered.length) { alert("Primero ejecuta 'Extraer'"); return; }
                const kml = buildKML(filtered);
                const zip = new JSZip();
                zip.file("postes_filtrados.kml", kml);
                const blob = await zip.generateAsync({ type: "blob" });
                const a = document.createElement("a");
                a.href = URL.createObjectURL(blob);
                a.download = "postes_filtrados.kmz";
                a.click();
                URL.revokeObjectURL(a.href);
            };

            document.getElementById("btnShowMap").onclick = () => {
                const mapDiv = document.getElementById("map");
                mapDiv.style.display = "block";
                if (!map) {
                    map = L.map("map");
                    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 19, attribution: "¬© OpenStreetMap" }).addTo(map);
                    layerLine = L.geoJSON(null, { style: { color: "#0ea5e9", weight: 3 } }).addTo(map);
                    layerPostesFiltered = L.layerGroup().addTo(map);
                    map.setView([-9.4, -77.57], 12);
                }
                layerLine.clearLayers();
                layerPostesFiltered.clearLayers();

                if (line) {
                    layerLine.addData(line);
                    map.fitBounds(layerLine.getBounds(), { padding: [20, 20] });
                }
                if (filtered.length) {
                    filtered.forEach(p => {
                        L.circleMarker([p.lat, p.lon], { radius: 5 })
                            .bindPopup(`<b>${p.name}</b>`)
                            .addTo(layerPostesFiltered);
                    });
                    const group = L.featureGroup([layerLine, layerPostesFiltered]);
                    map.fitBounds(group.getBounds(), { padding: [20, 20] });
                }
            };

            // Estado inicial
            setLineLoaded(false);

            // PRECARGA en segundo plano al cargar la p√°gina (sin bloquear la UI)
            window.addEventListener('load', () => {
                if ('requestIdleCallback' in window) {
                    requestIdleCallback(() => ensurePostsLoaded(), { timeout: 3000 });
                } else {
                    setTimeout(() => ensurePostsLoaded(), 1200);
                }
            });

            // ======================== ADICI√ìN JS: Dise√±o de postes ========================
            // Estado y capas nuevas (no interfiere con lo existente)
            let hasExtracted = false, hasShownMap = false;
            let designLayer = null;                      // Capa de previsualizaci√≥n (rojo)
            let designGenerated = [];                    // √öltimos puntos generados (previa)
            let designCounter = 0;                       // Secuencia P_Design_XX acumulada

            // Referencias UI nuevas
            const designCard = document.getElementById("designCard");
            const selStart = document.getElementById("designStart");
            const selEnd = document.getElementById("designEnd");
            const inputSpacing = document.getElementById("designSpacing");
            const btnPreview = document.getElementById("btnPreviewDesign");
            const btnInsert = document.getElementById("btnInsertDesign");
            const btnClear = document.getElementById("btnClearDesign");
            const elDesignCount = document.getElementById("designCount");

            // Mostrar tarjeta cuando se cumpla: Extraer + Ver en mapa
            function maybeShowDesignCard() {
                if (hasExtracted && hasShownMap) {
                    designCard.style.display = "block";
                    refreshDesignSelectors();
                    ensureDesignLayer();
                }
            }

            // Escucha adicional a botones existentes (NO se modifican los originales)
            document.getElementById("btnExtract").addEventListener("click", () => {
                hasExtracted = true;
                // Si hay resultado, actualizar selectores
                if (filtered && filtered.length) refreshDesignSelectors();
                // Reset de previa al extraer de nuevo
                clearDesignPreview();
                maybeShowDesignCard();
            });

            document.getElementById("btnShowMap").addEventListener("click", () => {
                hasShownMap = true;
                ensureDesignLayer();
                // Redibujar previa (si la hubiera)
                redrawDesignLayer();
                maybeShowDesignCard();
            });

            // Construye opciones de selects con los postes extra√≠dos (ordenados por 'location')
            function refreshDesignSelectors() {
                if (!filtered || !filtered.length || !line) {
                    selStart.innerHTML = "";
                    selEnd.innerHTML = "";
                    return;
                }

                const start = line.geometry.coordinates[0];                           // [lon,lat]
                const end = line.geometry.coordinates[line.geometry.coordinates.length - 1];

                // ‚¨áÔ∏è INICIO y FIN muestran coordenadas reales de la l√≠nea y usan valores sentinela
                const optInicio = `<option value="-1">INICIO ¬∑ ${start[1].toFixed(6)}, ${start[0].toFixed(6)}</option>`;
                const optFin = `<option value="${filtered.length}">FIN ¬∑ ${end[1].toFixed(6)}, ${end[0].toFixed(6)}</option>`;

                const cuerpo = filtered.map((p, i) => {
                    const loc = typeof p.location === "number" ? Math.round(p.location) : "-";
                    return `<option value="${i}">${i.toString().padStart(3, "0")} ¬∑ ${p.name} ¬∑ ${loc} m</option>`;
                }).join("");

                // INICIO (l√≠nea) + postes   /   postes + FIN (l√≠nea)
                selStart.innerHTML = optInicio + cuerpo;
                selEnd.innerHTML = cuerpo + optFin;

                // Por defecto: de INICIO (l√≠nea) a FIN (l√≠nea)
                selStart.value = "-1";
                selEnd.value = String(filtered.length);
            }





            // Capa de previsualizaci√≥n (rojo)
            function ensureDesignLayer() {
                if (map && !designLayer) {
                    designLayer = L.layerGroup().addTo(map);
                }
            }
            function redrawDesignLayer() {
                if (!designLayer) return;
                designLayer.clearLayers();
                // Dibuja s√≥lo la previa (a√∫n no insertada en 'filtered')
                designGenerated.forEach(p => {
                    L.circleMarker([p.lat, p.lon], { radius: 5, color: "#e11d48", fillColor: "#e11d48", fillOpacity: 1 })
                        .bindPopup(`<b>${p.name}</b>`)
                        .addTo(designLayer);
                });
            }
            function clearDesignPreview() {
                designGenerated = [];
                elDesignCount.textContent = "0";
                btnInsert.disabled = true;
                redrawDesignLayer();
            }

            // Utilidades Turf (proyecci√≥n y slicing)
            function projectPointOnLine(ll) { // ll = [lon, lat]
                return turf.nearestPointOnLine(line, turf.point(ll), { units: "meters" });
            }
            function locationAlongLineFromStart(pt) { // metros desde inicio de 'line'
                const startPt = turf.point(line.geometry.coordinates[0]);
                const slice = turf.lineSlice(startPt, pt, line);
                return turf.length(slice, { units: "kilometers" }) * 1000;
            }
            // Genera postes entre el extremo real de la l√≠nea (inicio o fin) y un poste.
            btnPreview.addEventListener("click", () => {
                const spacing = Math.max(5, Number(inputSpacing.value) || 60);
                if (!line) { alert("Primero carga la L√çNEA y ejecuta 'Extraer'."); return; }

                const startVal = selStart.value;                   // "-1" = INICIO (l√≠nea), "0..N-1" = poste
                const endVal = selEnd.value;                     // "0..N-1" = poste, "N" = FIN (l√≠nea)
                const lastIdx = filtered.length - 1;

                const isInicioLine = (startVal === "-1");
                const isFinLine = (endVal === String(filtered.length));

                const startIdx = isInicioLine ? 0 : parseInt(startVal, 10);
                const endIdx = isFinLine ? lastIdx : parseInt(endVal, 10);

                if (!Number.isInteger(startIdx) || !Number.isInteger(endIdx)) {
                    alert("Selecciona origen y fin v√°lidos."); return;
                }
                if (!isInicioLine && !isFinLine && startIdx === endIdx) {
                    alert("Origen y fin no pueden ser el mismo poste."); return;
                }

                // Casos de borde: extremos de la l√≠nea con el primer/√∫ltimo poste
                if (isInicioLine && endIdx === 0) {
                    designGenerated = generateDesignFromLineToPost(true, 0, spacing);        // INICIO ‚Üí primer poste
                } else if (isFinLine && startIdx === lastIdx) {
                    designGenerated = generateDesignFromLineToPost(false, lastIdx, spacing); // √∫ltimo poste ‚Üí FIN
                } else {
                    designGenerated = generateDesignBetween(startIdx, endIdx, spacing);      // resto de casos
                }

                elDesignCount.textContent = String(designGenerated.length);
                btnInsert.disabled = designGenerated.length === 0;
                ensureDesignLayer();
                redrawDesignLayer();
                if (map && (designGenerated.length || filtered.length)) {
                    const group = L.featureGroup([]);
                    if (layerLine) group.addLayer(layerLine);
                    if (layerPostesFiltered) group.addLayer(layerPostesFiltered);
                    if (designLayer) group.addLayer(designLayer);
                    try { map.fitBounds(group.getBounds(), { padding: [20, 20] }); } catch (_) { }
                }
            });


            // Generar postes cada 'spacingM' entre los puntos elegidos, siguiendo la l√≠nea
            function generateDesignBetween(startIdx, endIdx, spacingM) {
                if (!line || !filtered?.length) return [];

                // Asegurar orden por 'location'
                let a = Math.min(startIdx, endIdx);
                let b = Math.max(startIdx, endIdx);

                const pA = filtered[a];
                const pB = filtered[b];

                // Proyectar ambos sobre la l√≠nea real
                const projA = projectPointOnLine([pA.lon, pA.lat]);
                const projB = projectPointOnLine([pB.lon, pB.lat]);
                // Asegurar orden seg√∫n progreso real sobre la l√≠nea
                const locA = locationAlongLineFromStart(projA);
                const locB = locationAlongLineFromStart(projB);
                let startProj = projA, endProj = projB, startLoc = locA, endLoc = locB;
                if (locB < locA) {
                    startProj = projB; endProj = projA; startLoc = locB; endLoc = locA;
                }

                const segment = turf.lineSlice(startProj, endProj, line);
                const segLenM = turf.length(segment, { units: "kilometers" }) * 1000;

                const out = [];
                for (let d = spacingM; d < segLenM; d += spacingM) {
                    const pt = turf.along(segment, d / 1000, { units: "kilometers" });
                    const [lon, lat] = pt.geometry.coordinates;
                    designCounter += 1;
                    const name = `P_Design_${String(designCounter).padStart(2, "0")}`;
                    // 'location' absoluto desde inicio de la l√≠nea
                    const locAbs = startLoc + d;
                    out.push({ name, lat, lon, location: locAbs, distance: 0, designed: true });
                }
                return out;
            }

            // Redibuja el mapa con 'filtered' completo, coloreando los dise√±ados distinto
            function redrawAllPostsColoring() {
                if (!map || !layerPostesFiltered) return;
                layerPostesFiltered.clearLayers();

                const markers = [];
                filtered.forEach(p => {
                    const isDesigned = !!p.designed;
                    const opts = isDesigned
                        ? { radius: 5, color: "#e11d48", fillColor: "#e11d48", fillOpacity: 1 }
                        : { radius: 5 };
                    markers.push(L.circleMarker([p.lat, p.lon], opts).bindPopup(`<b>${p.name}</b>`).addTo(layerPostesFiltered));
                });

                // Ajuste de vista (usar capa existente + l√≠nea si hay)
                if (layerLine) {
                    const group = L.featureGroup([layerLine, layerPostesFiltered]);
                    try { map.fitBounds(group.getBounds(), { padding: [20, 20] }); } catch (_) { }
                }
            }

            // Bot√≥n: Previsualizar
            btnPreview.addEventListener("click", () => {
                const startVal = selStart.value;                 // "-1" = INICIO, "0..N-1" = poste
                const endVal = selEnd.value;                   // "0..N-1" = poste, "N" = FIN
                const spacing = Math.max(5, Number(inputSpacing.value) || 60);

                if (!line) { alert("Primero carga la L√çNEA y ejecuta 'Extraer'."); return; }
                if (startVal === endVal) { alert("Origen y fin no pueden ser el mismo poste."); return; }

                const lastIdx = filtered.length - 1;
                const isInicioLine = (startVal === "-1");
                const isFinLine = (endVal === String(filtered.length));

                const startIdx = isInicioLine ? 0 : parseInt(startVal, 10);
                const endIdx = isFinLine ? lastIdx : parseInt(endVal, 10);

                // üéØ Casos borde que antes daban segmento 0 m:
                if (isInicioLine && endIdx === 0) {
                    designGenerated = generateDesignFromLineToPost(true, 0, spacing);      // INICIO ‚Üí primer poste
                } else if (isFinLine && startIdx === lastIdx) {
                    designGenerated = generateDesignFromLineToPost(false, lastIdx, spacing); // √∫ltimo poste ‚Üí FIN
                } else {
                    // Resto de casos, usa tu generador normal
                    designGenerated = generateDesignBetween(startIdx, endIdx, spacing);
                }

                elDesignCount.textContent = String(designGenerated.length);
                btnInsert.disabled = designGenerated.length === 0;

                ensureDesignLayer();
                redrawDesignLayer();

                if (map && (designGenerated.length || filtered.length)) {
                    const group = L.featureGroup([]);
                    if (layerLine) group.addLayer(layerLine);
                    if (layerPostesFiltered) group.addLayer(layerPostesFiltered);
                    if (designLayer) group.addLayer(designLayer);
                    try { map.fitBounds(group.getBounds(), { padding: [20, 20] }); } catch (_) { }
                }
            });


            // Bot√≥n: Insertar al resultado (modifica 'filtered', TXT/KMZ heredar√°n esto)
            btnInsert.addEventListener("click", () => {
                if (!designGenerated.length) { alert("Nada que insertar. Previsualiza primero."); return; }

                // Insertar manteniendo el orden por 'location'
                // 1) Unir y reordenar por 'location'
                filtered.push(...designGenerated);
                filtered.sort((a, b) => (a.location ?? 0) - (b.location ?? 0));

                // 2) Actualizar UI heredada
                setResultCount(filtered.length);
                updateLengthComparison(filtered);
                document.getElementById("output").value = resultToTextOrdered(filtered);

                // 3) Redibujar mapa coloreando dise√±ados
                redrawAllPostsColoring();

                // 4) Limpiar previa (ya est√°n insertados)
                clearDesignPreview();

                // 5) Refrescar selects (lista creci√≥)
                refreshDesignSelectors();

                alert("Postes dise√±ados insertados en el resultado.");
            });

            // Bot√≥n: Limpiar dise√±o actual (solo la previsualizaci√≥n)
            btnClear.addEventListener("click", () => {
                clearDesignPreview();
            });
            // ====================== FIN ADICI√ìN JS: Dise√±o de postes ======================


        })();
    </script>
</body>

</html>
