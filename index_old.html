<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>BITEL MT pole extractor</title>

<!-- Anti-cache del HTML -->
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">

<!-- Pequeñas optimizaciones de red -->
<link rel="preconnect" href="https://unpkg.com">
<link rel="dns-prefetch" href="https://unpkg.com">

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script defer src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script defer src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
<script defer src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
<script defer src="https://unpkg.com/@tmcw/togeojson@5.8.1/dist/togeojson.umd.js"></script>
<script defer src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

<style>
  :root{ --accent:#10b981; }
  *{ box-sizing:border-box; }
  body{ font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif; background:#f3f4f6; color:#111827; margin:0; }
  header{ display:flex; align-items:center; gap:12px; padding:20px; justify-content:center;}
  header img{ height:48px; }
  h1{ font-size:22px; margin:0; font-weight:700; }
  .bar{display:flex; gap:12px; justify-content:center; padding:16px; flex-wrap:wrap;}
  .btn{ background:#2d2d2d; color:white; border:none; padding:12px 16px; border-radius:10px; cursor:pointer; font-weight:600; }
  .btn.secondary{ background:#6b7280; }
  .btn.accent{ background:var(--accent); }
  .btn:disabled{ opacity:.6; cursor:not-allowed; }
  .card{background:white; border-radius:12px; box-shadow:0 6px 18px rgba(0,0,0,.08); width:min(1100px,92vw); margin:0 auto 18px; padding:16px;}
  .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
  input[type="number"], input[type="file"]{ padding:10px 12px; border:1px solid #d1d5db; border-radius:8px; }
  #map{ height:520px; border-radius:12px; }
  textarea{ width:100%; min-height:180px; border:1px solid #d1d5db; border-radius:10px; padding:12px; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  .pill{ background:#e5e7eb; padding:6px 10px; border-radius:999px; font-size:12px; }
  .muted{ color:#6b7280; }
  .status{ font-size:12px; color:#374151; display:grid; grid-auto-flow:column; gap:18px; width:max-content; }
  .ok{ color:#059669; } .bad{ color:#dc2626; }
  .kpi{ font-size:13px; margin:6px 0 10px; }
  .kpi b{ color:#111827; }
</style>
</head>
<body>
<header>
  <h1>BITEL MT pole extractor</h1>
</header>

<div class="bar">
  <input id="fileLine" type="file" accept=".kmz,.kml" hidden />
  <button class="btn accent" id="btnPickLine">Seleccionar Línea KMZ/KML</button>
  <span class="pill">Base: <b id="baseName">postes.csv.zip</b></span>
  <label class="pill">Radio (m): <input id="radius" type="number" value="20" min="1"></label>
  <button class="btn" id="btnExtract">Extraer</button>
  <button class="btn" id="btnCopy">Copiar</button>
  <button class="btn" id="btnDownloadTXT">Descargar TXT</button>
  <button class="btn" id="btnDownloadKMZ">Descargar KMZ</button>
  <button class="btn secondary" id="btnShowMap">Ver en mapa</button>
</div>

<div class="card">
  <div class="row muted" style="margin-bottom:8px;">
    <span>La app cargará <b>postes.csv.zip</b> cuando lo necesite. También puedes cargar CSV(s) manualmente:</span>
    <input id="filePosts" type="file" accept=".csv" multiple>
  </div>
  <div class="status">
    <div id="statusPosts">Postes cargados: <b>0</b></div>
    <div id="statusLine">Línea: <b class="bad">no cargada</b></div>
    <div id="statusResult">Filtrados: <b>0</b></div>
  </div>
  <div id="map" style="display:none; margin-top:10px;"></div>
</div>

<div class="card">
  <div id="compare" class="kpi muted">Comparación de longitudes: <b>—</b></div>
  <textarea id="output" placeholder="INICIO;lat;lon&#10;Nombre;lat;lon&#10;...&#10;FIN;lat;lon"></textarea>
</div>

<script>
(function(){
  const ZIP_NAME = "postes.csv.zip";
  let postes = [];          // [{name, lat, lon}]
  let filtered = [];        // [{name, lat, lon, location, distance}]
  let line = null;          // Feature<LineString>
  let map, layerLine, layerPostesFiltered;
  let postsLoaded = false;

  // ---------- Estado UI ----------
  const elBase = document.getElementById("baseName");
  const stPosts = document.getElementById("statusPosts");
  const stLine  = document.getElementById("statusLine");
  const stRes   = document.getElementById("statusResult");
  const elCompare = document.getElementById("compare");
  function setPostsCount(n){ stPosts.innerHTML = "Postes cargados: <b>"+n+"</b>"; }
  function setLineLoaded(ok){
    stLine.innerHTML = "Línea: <b class='"+(ok?"ok":"bad")+"'>"+(ok?"cargada":"no cargada")+"</b>";
  }
  function setResultCount(n){ stRes.innerHTML = "Filtrados: <b>"+n+"</b>"; }
  function setCompareText(t){ elCompare.innerHTML = "Comparación de longitudes: <b>"+t+"</b>"; }

  // ---------- Utilidades ----------
  async function fetchBlob(url){
    const r = await fetch(url + "?v=" + Date.now(), {cache:"no-store"});
    if(!r.ok) throw new Error("No se pudo cargar " + url);
    return await r.blob();
  }

  // PapaParse en worker (no bloquea la UI)
  function parseCSVWithPapaAsync(text){
    return new Promise((resolve)=>{
      const out = [];
      Papa.parse(text, {
        header: true,
        skipEmptyLines: true,
        worker: true,
        step: (row)=>{
          const r = row.data;
          const name = (r.Nombre ?? r.name ?? r.NAME ?? "Sin nombre").toString();
          const lat  = parseFloat(r.Latitud ?? r.lat ?? r.LAT);
          const lon  = parseFloat(r.Longitud ?? r.lon ?? r.LON);
          if(!isNaN(lat) && !isNaN(lon)) out.push({name, lat, lon});
        },
        complete: ()=> resolve(out)
      });
    });
  }

  async function loadCSVFromZip(zipName = ZIP_NAME){
    const blob = await fetchBlob(zipName);
    const zip = await JSZip.loadAsync(blob);
    const entry = Object.keys(zip.files).find(n => n.toLowerCase().endsWith(".csv"));
    if(!entry) throw new Error("El ZIP no contiene un CSV");
    const csvText = await zip.files[entry].async("text");
    return await parseCSVWithPapaAsync(csvText);
  }

  // ← ESTA ES LA FUNCIÓN QUE YA TIENES
  async function ensurePostsLoaded(){
    if(postsLoaded) return;
    try{
      postes = await loadCSVFromZip(ZIP_NAME);
      postsLoaded = true;
      setPostsCount(postes.length);
      elBase.textContent = `${ZIP_NAME} (${postes.length} pts)`;
    }catch(e){
      console.warn("No se pudo cargar postes.csv.zip automáticamente:", e);
      elBase.textContent = `${ZIP_NAME} (no cargado)`;
      alert("No se pudo cargar postes.csv.zip. Puedes cargar CSV(s) manualmente.");
    }
  }

  async function readKMZtoKMLText(file){
    const zip = await JSZip.loadAsync(file);
    const kmlEntry = Object.keys(zip.files).find(n => n.toLowerCase().endsWith(".kml"));
    if(!kmlEntry) throw new Error("El KMZ no contiene un KML");
    return await zip.files[kmlEntry].async("text");
  }

  function parseKmlTextToGeoJSON(kmlText){
    const parser = new DOMParser();
    const doc = parser.parseFromString(kmlText, "text/xml");
    return toGeoJSON.kml(doc);
  }

  function lineStringFromGeojson(gj){
    for(const f of gj.features||[]){
      if(f.geometry && f.geometry.type==="LineString") return f;
    }
    return null;
  }

  // --- Prefiltro por BBOX + margen ---
  function metersToLatDeg(m){ return m / 111320; }
  function metersToLonDegAtLat(m, latDeg){
    const k = 111320 * Math.cos(latDeg * Math.PI/180);
    return m / (k === 0 ? 1 : k);
  }
  function bboxWithMargin(lineFeature, marginM){
    const [minLon, minLat, maxLon, maxLat] = turf.bbox(lineFeature);
    const midLat = (minLat + maxLat)/2;
    const dLat = metersToLatDeg(marginM);
    const dLon = metersToLonDegAtLat(marginM, midLat);
    return [minLon - dLon, minLat - dLat, maxLon + dLon, maxLat + dLat];
  }
  function preselectByBbox(points, bbox){
    const [minLon, minLat, maxLon, maxLat] = bbox;
    return points.filter(p => (
      p.lat >= minLat && p.lat <= maxLat &&
      p.lon >= minLon && p.lon <= maxLon
    ));
  }

  // --- Cálculo final (solo sobre candidatos del bbox) ---
  function computeAlongLine(radiusM){
    if(!line || !postes.length) return [];
    const bbox = bboxWithMargin(line, radiusM + 30); // holgura
    const candidates = preselectByBbox(postes, bbox);

    const startCoord = line.geometry.coordinates[0];
    const startPt = turf.point(startCoord);
    const out = [];

    for(const p of candidates){
      const pt = turf.point([p.lon, p.lat]);
      const distM = turf.pointToLineDistance(pt, line, {units:"meters"});
      if(distM > radiusM) continue;

      const proj = turf.nearestPointOnLine(line, pt, {units:"meters"});
      const slice = turf.lineSlice(startPt, proj, line);
      const locM  = turf.length(slice, {units:"kilometers"}) * 1000;

      out.push({ ...p, distance: distM, location: locM });
    }
    out.sort((a,b)=> a.location - b.location);
    return out;
  }

  function resultToTextOrdered(rows){
    if(!line) return "";
    const start = line.geometry.coordinates[0];
    const end   = line.geometry.coordinates[line.geometry.coordinates.length-1];
    const lines = [];
    lines.push(`INICIO;${start[1].toFixed(6)};${start[0].toFixed(6)}`);
    rows.forEach(r => lines.push(`${r.name};${r.lat.toFixed(6)};${r.lon.toFixed(6)}`));
    lines.push(`FIN;${end[1].toFixed(6)};${end[0].toFixed(6)}`);
    return lines.join("\n");
  }

  function escapeXml(s){ return s.replace(/[<>&'"]/g,c=>({"<":"&lt;",">":"&gt;","&":"&amp;","'":"&apos;",'"':"&quot;"}[c])); }

  function buildKML(rows){
    const header = `<?xml version="1.0" encoding="UTF-8"?>\n<kml xmlns="http://www.opengis.net/kml/2.2"><Document>`;
    const footer = `</Document></kml>`;
    const style = `<Style id="line"><LineStyle><color>ff00aaff</color><width>3</width></LineStyle></Style>
                   <Style id="pt"><IconStyle><color>ff10b981</color><scale>1.1</scale>
                   <Icon><href>http://maps.google.com/mapfiles/kml/paddle/grn-blank.png</href></Icon></IconStyle></Style>`;
    let linePlm = "";
    if(line){
      const coords = line.geometry.coordinates.map(([lon,lat])=>`${lon},${lat},0`).join(" ");
      linePlm = `<Placemark><name>Línea cargada</name><styleUrl>#line</styleUrl><LineString><coordinates>${coords}</coordinates></LineString></Placemark>`;
    }
    const ptsPlm = rows.map(r=>`<Placemark><name>${escapeXml(r.name)}</name><styleUrl>#pt</styleUrl><Point><coordinates>${r.lon},${r.lat},0</coordinates></Point></Placemark>`).join("");
    return header + style + linePlm + ptsPlm + footer;
  }

  function updateLengthComparison(rows){
    if(!line){ setCompareText("—"); return; }
    const originalLenM  = turf.length(line, {units:"kilometers"}) * 1000;
    const start = line.geometry.coordinates[0];
    const end   = line.geometry.coordinates[line.geometry.coordinates.length-1];
    const genCoords = [start, ...rows.map(r=>[r.lon, r.lat]), end];
    const generatedLenM = genCoords.length >= 2
        ? turf.length(turf.lineString(genCoords), {units:"kilometers"}) * 1000
        : 0;
    const dif = generatedLenM - originalLenM;
    const f = n => n.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g,".");
    setCompareText(`Original: ${f(originalLenM)} m | Generada (uniendo postes): ${f(generatedLenM)} m | Δ: ${f(dif)} m`);
  }

  // ---------- Eventos UI ----------
  document.getElementById("btnPickLine").onclick = ()=> document.getElementById("fileLine").click();

  document.getElementById("fileLine").addEventListener("change", async (ev)=>{
    const file = ev.target.files[0]; if(!file) return;
    let kmlText;
    if(file.name.toLowerCase().endsWith(".kmz")) kmlText = await readKMZtoKMLText(file);
    else kmlText = await file.text();
    const gj = parseKmlTextToGeoJSON(kmlText);
    line = lineStringFromGeojson(gj);
    setLineLoaded(!!line);
    if(!line){ alert("No se encontró una LineString en el archivo."); return; }
    setCompareText("—");
    // PRECARGA la base justo después de cargar la línea
    await ensurePostsLoaded();
  });

  // Carga manual de CSV(s) (fallback)
  document.getElementById("filePosts").addEventListener("change", async (ev)=>{
    postes = [];
    for(const file of ev.target.files){
      const txt = await file.text();
      const arr = await parseCSVWithPapaAsync(txt);
      postes.push(...arr);
    }
    postsLoaded = true;
    setPostsCount(postes.length);
    elBase.textContent = `Cargados manualmente (${postes.length} pts)`;
    alert("Base de postes cargada: "+postes.length+" puntos.");
  });

  document.getElementById("btnExtract").onclick = async ()=>{
    if(!line){ alert("Carga primero la LÍNEA (KMZ/KML)."); return; }
    if(!postsLoaded){ await ensurePostsLoaded(); if(!postsLoaded) return; }

    const radius = Number(document.getElementById("radius").value)||20;
    filtered = computeAlongLine(radius);

    document.getElementById("output").value = resultToTextOrdered(filtered);
    setResultCount(filtered.length);
    updateLengthComparison(filtered);
  };

  document.getElementById("btnCopy").onclick = async ()=>{
    const txt = document.getElementById("output").value || "";
    if(!txt){ alert("No hay contenido para copiar"); return; }
    await navigator.clipboard.writeText(txt);
    alert("Resultado copiado al portapapeles.");
  };

  document.getElementById("btnDownloadTXT").onclick = ()=>{
    const txt = document.getElementById("output").value || "";
    const blob = new Blob([txt], {type:"text/plain;charset=utf-8"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "postes_filtrados.txt";
    a.click();
    URL.revokeObjectURL(a.href);
  };

  document.getElementById("btnDownloadKMZ").onclick = async ()=>{
    if(!filtered.length){ alert("Primero ejecuta 'Extraer'"); return; }
    const kml = buildKML(filtered);
    const zip = new JSZip();
    zip.file("postes_filtrados.kml", kml);
    const blob = await zip.generateAsync({type:"blob"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "postes_filtrados.kmz";
    a.click();
    URL.revokeObjectURL(a.href);
  };

  document.getElementById("btnShowMap").onclick = ()=>{
    const mapDiv = document.getElementById("map");
    mapDiv.style.display = "block";
    if(!map){
      map = L.map("map");
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",{ maxZoom:19, attribution:"© OpenStreetMap" }).addTo(map);
      layerLine = L.geoJSON(null, {style:{color:"#0ea5e9", weight:3}}).addTo(map);
      layerPostesFiltered = L.layerGroup().addTo(map);
      map.setView([-9.4, -77.57], 12);
    }
    layerLine.clearLayers();
    layerPostesFiltered.clearLayers();

    if(line){
      layerLine.addData(line);
      map.fitBounds(layerLine.getBounds(), {padding:[20,20]});
    }
    if(filtered.length){
      filtered.forEach(p=>{
        L.circleMarker([p.lat, p.lon], {radius:5})
          .bindPopup(`<b>${p.name}</b>`)
          .addTo(layerPostesFiltered);
      });
      const group = L.featureGroup([layerLine, layerPostesFiltered]);
      map.fitBounds(group.getBounds(), {padding:[20,20]});
    }
  };

  // Estado inicial
  setLineLoaded(false);

  // PRECARGA en segundo plano al cargar la página (sin bloquear la UI)
  window.addEventListener('load', ()=>{
    if ('requestIdleCallback' in window) {
      requestIdleCallback(()=>ensurePostsLoaded(), {timeout: 3000});
    } else {
      setTimeout(()=>ensurePostsLoaded(), 1200);
    }
  });
})();
</script>
</body>
</html>
